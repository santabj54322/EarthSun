<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>천구 좌표계 시뮬레이션 (제삼자 시점)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            /* 배경색을 바꾸고 싶으면 아래 그라디언트를 수정하세요 */
            background: linear-gradient(135deg, #0a0a0f 0%, #101427 100%);
            color: white;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        #container {
            display: grid;
            grid-template-columns: 1fr 2fr; /* 1/3 : 2/3 */
            grid-template-rows: 1fr;
            gap: 10px;
            padding: 10px;
            height: 100vh;
            width: 100vw;
        }
        .canvas-container {
            /* 천구가 더 잘 보이도록 배경을 진하게 */
            background: rgba(10, 12, 24, 0.95);
            border-radius: 10px;
            border: 1px solid rgba(100, 100, 150, 0.3);
            position: relative;
            overflow: hidden;
        }
        .canvas-title {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 10;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 30, 40, 0.95);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(100, 100, 150, 0.5);
            z-index: 100;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 12px; color: #aaa; }
        input, select {
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #444;
            background: #222;
            color: white;
            width: 120px;
        }
        button {
            padding: 8px 20px;
            background: linear-gradient(135deg, #4a5568, #2d3748);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover { background: linear-gradient(135deg, #5a6578, #3d4758); transform: translateY(-2px); }
        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(30, 30, 40, 0.95);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 250px;
            z-index: 100;
        }
        .info-item {
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(100, 100, 150, 0.2);
        }
        .info-label { color: #8a8a8a; font-size: 12px; }
        .info-value { color: #fff; font-weight: bold; }

        /* 천구 범례 */
        .sphere-legend {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.75);
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid rgba(100,100,150,0.35);
            font-size: 12px;
            line-height: 1.4;
            z-index: 20;
            max-width: 60%;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; margin: 3px 0; }
        .legend-swatch { width: 12px; height: 12px; border-radius: 2px; display: inline-block; }
        .swatch-equator { background: #ff4444; }
        .swatch-ecliptic { background: #ffdd00; }
        .swatch-horizon { background: #00ff88; }
        .swatch-sunpath { background: #ffa500; }
        .swatch-sun { background: #ffff00; }
        .legend-note { color: #9aa; margin-top: 6px; }
    </style>
</head>
<body>
    <div id="container">
        <div class="canvas-container" id="topView">
            <div class="canvas-title">태양-지구 (위에서 본 모습)</div>
        </div>
        <div class="canvas-container" id="celestialSphere">
            <div class="canvas-title">천구 (제삼자 시점)</div>
            <div class="sphere-legend">
                <div class="legend-item"><span class="legend-swatch swatch-equator"></span>적도(Equator)</div>
                <div class="legend-item"><span class="legend-swatch swatch-ecliptic"></span>황도(Ecliptic)</div>
                <div class="legend-item"><span class="legend-swatch swatch-horizon"></span>지평선(Horizon) 디스크</div>
                <div class="legend-item"><span class="legend-swatch swatch-sunpath"></span>태양의 일주 소권(해당 적위)</div>
                <div class="legend-item"><span class="legend-swatch swatch-sun"></span>태양 위치(적경·적위)</div>
                <div class="legend-note">참고: 장면은 남중 시각으로 정렬(LST = RA). 날짜/시간 계산 없음.</div>
            </div>
        </div>
    </div>
    
    <div id="controls">
        <div class="control-group">
            <label>태양 적경 (RA)</label>
            <select id="rightAscension">
                <option value="0">0h (춘분)</option>
                <option value="6">6h (하지)</option>
                <option value="12">12h (추분)</option>
                <option value="18">18h (동지)</option>
            </select>
        </div>
        <div class="control-group">
            <label>관측자 위도</label>
            <input type="number" id="latitude" value="37.5" min="-90" max="90" step="0.1">
        </div>
        <div class="control-group">
            <label>관측자 경도</label>
            <input type="number" id="longitude" value="127" min="-180" max="180" step="0.1">
        </div>
        <button onclick="updateSimulation()">적용</button>
    </div>
    
    <div id="info">
        <div class="info-item">
            <div class="info-label">일출 방위각</div>
            <div class="info-value" id="sunriseAzimuth">-</div>
        </div>
        <div class="info-item">
            <div class="info-label">일몰 방위각</div>
            <div class="info-value" id="sunsetAzimuth">-</div>
        </div>
        <div class="info-item">
            <div class="info-label">남중 고도</div>
            <div class="info-value" id="noonAltitude">-</div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 전역 변수
        let topScene, topCamera, topRenderer;
        let sphereScene, sphereCamera, sphereRenderer;
        let earthTop;
        let observerLat = 37.5, observerLon = 127;
        let sunRA = 0; // 시간 단위 (h)

        const DEG = Math.PI / 180;
        const RAD2DEG = 180 / Math.PI;
        const earthTilt = 23.5 * DEG; // 23.5°

        // 천구 뷰 오브젝트 참조
        let celestialSphereMesh, equatorRing, eclipticRing;
        let horizonRing, horizonGroup, horizonDisk;
        let sunPathMesh = null, sunMarker = null;
        let skyGroup; // 적도/황도/태양/일주소권을 묶는 그룹(지평선은 고정)

        // 위에서 본 뷰 초기화
        function initTopView() {
            const container = document.getElementById('topView');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            topScene = new THREE.Scene();
            topCamera = new THREE.OrthographicCamera(-20, 20, 20 * height/width, -20 * height/width, 0.1, 1000);
            topCamera.position.set(0, 50, 0);
            topCamera.lookAt(0, 0, 0);
            
            topRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            topRenderer.setSize(width, height);
            topRenderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(topRenderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0x808080);
            topScene.add(ambientLight);
            
            // 태양(중앙)
            const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const sunTop = new THREE.Mesh(sunGeometry, sunMaterial);
            topScene.add(sunTop);
            
            // 지구 궤도
            const orbitGeometry = new THREE.RingGeometry(14.5, 15.5, 128);
            const orbitMaterial = new THREE.MeshBasicMaterial({ color: 0x4444ff, opacity: 0.6, transparent: true, side: THREE.DoubleSide });
            const orbitTop = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbitTop.rotation.x = -Math.PI / 2; // XZ 평면
            topScene.add(orbitTop);

            // 지구(상단 뷰)
            const earthGeometry = new THREE.SphereGeometry(1, 16, 16);
            const earthMaterial = new THREE.MeshBasicMaterial({ color: 0x2244ff });
            earthTop = new THREE.Mesh(earthGeometry, earthMaterial);
            topScene.add(earthTop);
        }
        
        // 천구 뷰 초기화 (제삼자 시점)
        function initCelestialSphere() {
            const container = document.getElementById('celestialSphere');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            sphereScene = new THREE.Scene();
            sphereCamera = new THREE.PerspectiveCamera(60, width / height, 0.1, 2000);

            // 제삼자 시점 카메라 위치(구 바깥)
            let camSpherical = new THREE.Spherical(140, Math.PI/3, Math.PI/4);
            sphereCamera.position.setFromSpherical(camSpherical);
            sphereCamera.lookAt(0, 0, 0);
            
            sphereRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            sphereRenderer.setSize(width, height);
            sphereRenderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(sphereRenderer.domElement);
            
            // 하늘 요소 그룹(적도/황도/태양/일주소권/천구 메쉬)
            skyGroup = new THREE.Object3D();
            sphereScene.add(skyGroup);

            // 천구(반투명)
            const R = 50;
            const sphereGeometry = new THREE.SphereGeometry(R, 64, 64);
            // 조금 더 보이도록 opacity 약간 올림
            const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x0b1040, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
            celestialSphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
            skyGroup.add(celestialSphereMesh);
            
            // 적도(Equator) - 세계 좌표에서 XY 평면, NCP는 +Z
            const equatorGeometry = new THREE.TorusGeometry(R, 0.2, 8, 128);
            const equatorMaterial = new THREE.MeshBasicMaterial({ color: 0xff4444 });
            equatorRing = new THREE.Mesh(equatorGeometry, equatorMaterial);
            equatorRing.rotation.set(0, 0, 0); // XY 평면
            skyGroup.add(equatorRing);
            
            // 황도(Ecliptic) - 적도 기준 23.5° 기울임(γ점 +X)
            const eclipticGeometry = new THREE.TorusGeometry(R, 0.2, 8, 128);
            const eclipticMaterial = new THREE.MeshBasicMaterial({ color: 0xffdd00 });
            eclipticRing = new THREE.Mesh(eclipticGeometry, eclipticMaterial);
            eclipticRing.rotation.x = earthTilt; // X축 기준 기울임(관측자와 무관, 항상 23.5°)
            skyGroup.add(eclipticRing);
            
            // 지평선(Horizon) - 관측자 위도 φ에 따라 x 기울기만 적용(남중 정렬은 skyGroup z회전으로 처리)
            const horizonGeometry = new THREE.TorusGeometry(R, 0.2, 8, 128);
            const horizonMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
            horizonRing = new THREE.Mesh(horizonGeometry, horizonMaterial);

            // 지평선 디스크(원판)
            const horizonDiskGeometry = new THREE.CircleGeometry(R - 0.1, 128);
            const horizonDiskMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff88, opacity: 0.15, transparent: true, side: THREE.DoubleSide });
            horizonDisk = new THREE.Mesh(horizonDiskGeometry, horizonDiskMaterial);

            horizonGroup = new THREE.Object3D();
            horizonGroup.add(horizonRing);
            horizonGroup.add(horizonDisk);
            sphereScene.add(horizonGroup);

            // 카메라 드래그/줌(우클릭 회전, 휠 줌)
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            container.addEventListener('mousedown', (e) => {
                if (e.button === 2) {
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            container.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    camSpherical.setFromVector3(sphereCamera.position.clone());
                    camSpherical.theta -= deltaX * 0.01;
                    camSpherical.phi += deltaY * 0.01;
                    camSpherical.phi = Math.max(0.05, Math.min(Math.PI - 0.05, camSpherical.phi));
                    sphereCamera.position.setFromSpherical(camSpherical);
                    sphereCamera.lookAt(0, 0, 0);
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            container.addEventListener('mouseup', () => { isDragging = false; });
            container.addEventListener('wheel', (e) => {
                camSpherical.setFromVector3(sphereCamera.position.clone());
                camSpherical.radius *= (e.deltaY > 0 ? 1.05 : 0.95);
                camSpherical.radius = Math.max(70, Math.min(400, camSpherical.radius));
                sphereCamera.position.setFromSpherical(camSpherical);
                sphereCamera.lookAt(0, 0, 0);
            });
            container.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        // 시뮬레이션 업데이트
        function updateSimulation() {
            sunRA = parseFloat(document.getElementById('rightAscension').value);
            observerLat = parseFloat(document.getElementById('latitude').value);
            observerLon = parseFloat(document.getElementById('longitude').value);
            
            // 선택된 RA는 (춘분/하지/추분/동지에서) 태양 황경 λ와 동일하게 간주
            const alpha = sunRA * Math.PI / 12;  // RA [rad]
            const lambda = alpha;                 // 4분점에서 α = λ
            
            // 상단(탑) 뷰의 지구 위치(춘분점이 화면 아래로, 반시계 춘→하→추→동)
            const earthAngle = lambda + Math.PI;
            const thetaTop = earthAngle + Math.PI / 2; // 화면 아래(-Z)를 λ=0으로 정렬
            const ex = 15 * Math.cos(thetaTop);
            const ez = 15 * Math.sin(thetaTop);
            if (earthTop) earthTop.position.set(ex, 0, ez);
            
            // 천구 업데이트
            updateCelestialSphere(alpha, lambda);
            
            // 태양 정보 계산
            calculateSunPosition(alpha, lambda);
        }
        
        // 천구 업데이트 (제삼자 시점)
        function updateCelestialSphere(alpha, lambda) {
            const latRad = observerLat * DEG;
            const epsilon = earthTilt;
            const R = 50;

            // 태양 적위 δ = asin(sin ε · sin λ)
            const declination = Math.asin(Math.sin(epsilon) * Math.sin(lambda));

            // 지평선 기울기: 위도만 반영 (x = π/2 − φ)
            horizonGroup.rotation.set(0, 0, 0);
            horizonRing.rotation.set(0, 0, 0);
            horizonDisk.rotation.set(0, 0, 0);
            horizonGroup.rotation.x = Math.PI / 2 - latRad;
            // 남중(LST=RA) 정렬은 skyGroup의 z 회전으로 처리:
            // 정합 보정: 기존 horizon z=α 대신 sky z=−α+π/2
            skyGroup.rotation.set(0, 0, 0);
            skyGroup.rotation.z = -alpha + Math.PI / 2;

            // 태양의 일주 경로(적위 고정 소권)
            if (sunPathMesh) {
                skyGroup.remove(sunPathMesh);
                sunPathMesh.geometry.dispose();
                sunPathMesh.material.dispose();
                sunPathMesh = null;
            }
            const rSmall = Math.max(0.1, R * Math.cos(declination)); // 소권 반지름
            const zOffset = R * Math.sin(declination);               // 소권 z 오프셋
            const sunPathGeometry = new THREE.RingGeometry(rSmall - 0.25, rSmall + 0.25, 256);
            const sunPathMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500, opacity: 0.85, transparent: true, side: THREE.DoubleSide });
            sunPathMesh = new THREE.Mesh(sunPathGeometry, sunPathMaterial);
            sunPathMesh.position.set(0, 0, zOffset); // 적도와 평행한 평면에서 z로 이동
            skyGroup.add(sunPathMesh);

            // 태양 위치(적경·적위 기준, skyGroup 안에서 배치)
            if (sunMarker) {
                skyGroup.remove(sunMarker);
                sunMarker.geometry.dispose();
                sunMarker.material.dispose();
                sunMarker = null;
            }
            const sunGeom = new THREE.SphereGeometry(2, 24, 24);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            sunMarker = new THREE.Mesh(sunGeom, sunMat);
            const x = R * Math.cos(declination) * Math.cos(alpha);
            const y = R * Math.cos(declination) * Math.sin(alpha);
            const z = R * Math.sin(declination);
            sunMarker.position.set(x, y, z);
            skyGroup.add(sunMarker);

            // 적도/황도(항상 skyGroup 내부)
            equatorRing.rotation.set(0, 0, 0);
            eclipticRing.rotation.set(earthTilt, 0, 0);
        }
        
        // 태양 위치 관련 값(남중 고도, 일출/일몰 방위각) 계산
        // 굴절/태양반지름 보정 없이 h0=0°, 원형 지구/천구 근사
        function calculateSunPosition(alpha, lambda) {
            const latRad = observerLat * DEG;
            const decRad = Math.asin(Math.sin(earthTilt) * Math.sin(lambda)); // 정확식

            // 남중 고도(근사)
            const noonAlt = 90 - Math.abs(observerLat - (decRad * RAD2DEG));

            // 일출/일몰 시간각(H0) 및 방위각(근사, h0=0)
            const tanLat = Math.tan(latRad);
            const tanDec = Math.tan(decRad);
            const cosH0 = -tanLat * tanDec;

            let sunriseAz = "-", sunsetAz = "-";

            if (cosH0 > 1) {
                sunriseAz = "극야";
                sunsetAz = "극야";
            } else if (cosH0 < -1) {
                sunriseAz = "백야";
                sunsetAz = "백야";
            } else {
                const H0 = Math.acos(Math.max(-1, Math.min(1, cosH0))); // 0~π
                // h=0에서
                const cosA = Math.sin(decRad) / Math.max(1e-9, Math.cos(latRad));
                const sinA_rise = Math.cos(decRad) * Math.sin(-H0);
                const sinA_set  = Math.cos(decRad) * Math.sin( H0);

                let Ar = Math.atan2(sinA_rise, cosA) * RAD2DEG;
                let As = Math.atan2(sinA_set,  cosA) * RAD2DEG;

                // 0~360 정규화
                Ar = (Ar % 360 + 360) % 360;
                As = (As % 360 + 360) % 360;

                sunriseAz = Ar.toFixed(1) + "°";
                sunsetAz  = As.toFixed(1) + "°";
            }

            document.getElementById('sunriseAzimuth').textContent = sunriseAz;
            document.getElementById('sunsetAzimuth').textContent = sunsetAz;
            document.getElementById('noonAltitude').textContent = noonAlt.toFixed(1) + "°";
        }
        
        // 애니메이션
        function animate() {
            requestAnimationFrame(animate);
            if (topRenderer && topScene && topCamera) topRenderer.render(topScene, topCamera);
            if (sphereRenderer && sphereScene && sphereCamera) sphereRenderer.render(sphereScene, sphereCamera);
        }
        
        // 윈도우 리사이즈 처리
        function onWindowResize() {
            const containers = ['topView', 'celestialSphere'];
            const renderers = [topRenderer, sphereRenderer];
            const cameras = [topCamera, sphereCamera];
            
            containers.forEach((id, index) => {
                const container = document.getElementById(id);
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                if (renderers[index]) {
                    renderers[index].setSize(width, height);
                    if (cameras[index] instanceof THREE.PerspectiveCamera) {
                        cameras[index].aspect = width / height;
                        cameras[index].updateProjectionMatrix();
                    } else if (cameras[index] instanceof THREE.OrthographicCamera) {
                        cameras[index].top = 20 * height/width;
                        cameras[index].bottom = -20 * height/width;
                        cameras[index].updateProjectionMatrix();
                    }
                }
            });
        }
        
        // 초기화
        window.addEventListener('load', () => {
            initTopView();
            initCelestialSphere();
            updateSimulation();
            animate();
            window.addEventListener('resize', onWindowResize);
        });
    </script>
</body>
</html>

배경색 변경 방법
- 전체 페이지 배경: CSS의 body { background: ... }를 원하는 색이나 그라디언트로 수정하세요.
- 각 뷰 박스 배경: .canvas-container { background: rgba(...); }를 수정해 대비를 조정하세요.
- 캔버스 자체 배경색을 쓰고 싶다면, renderer 생성 후 renderer.setClearColor('#0b1020', 1)처럼 설정할 수도 있습니다(지금은 alpha:true로 CSS 배경을 쓰도록 구성되어 있습니다).
