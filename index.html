<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>천구 좌표계 시뮬레이션 (제삼자 시점)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: white;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        #container {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            grid-template-rows: 1fr;
            gap: 10px;
            padding: 10px;
            height: 100vh;
            width: 100vw;
        }
        .canvas-container {
            background: rgba(20, 20, 30, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(100, 100, 150, 0.3);
            position: relative;
            overflow: hidden;
        }
        .canvas-title {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 10;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 30, 40, 0.95);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(100, 100, 150, 0.5);
            z-index: 100;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 12px; color: #aaa; }
        input, select {
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #444;
            background: #222;
            color: white;
            width: 120px;
        }
        button {
            padding: 8px 20px;
            background: linear-gradient(135deg, #4a5568, #2d3748);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover { background: linear-gradient(135deg, #5a6578, #3d4758); transform: translateY(-2px); }
        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(30, 30, 40, 0.95);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 250px;
            z-index: 100;
        }
        .info-item {
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(100, 100, 150, 0.2);
        }
        .info-label { color: #8a8a8a; font-size: 12px; }
        .info-value { color: #fff; font-weight: bold; }
    </style>
</head>
<body>
    <div id="container">
        <div class="canvas-container" id="topView">
            <div class="canvas-title">태양-지구 (위에서 본 모습)</div>
        </div>
        <div class="canvas-container" id="mainView">
            <div class="canvas-title">태양계 공전 (3D)</div>
        </div>
        <div class="canvas-container" id="celestialSphere">
            <div class="canvas-title">천구 (제삼자 시점)</div>
        </div>
    </div>
    
    <div id="controls">
        <div class="control-group">
            <label>태양 적경 (RA)</label>
            <select id="rightAscension">
                <option value="0">0h (춘분)</option>
                <option value="6">6h (하지)</option>
                <option value="12">12h (추분)</option>
                <option value="18">18h (동지)</option>
            </select>
        </div>
        <div class="control-group">
            <label>관측자 위도</label>
            <input type="number" id="latitude" value="37.5" min="-90" max="90" step="0.1">
        </div>
        <div class="control-group">
            <label>관측자 경도</label>
            <input type="number" id="longitude" value="127" min="-180" max="180" step="0.1">
        </div>
        <button onclick="updateSimulation()">적용</button>
    </div>
    
    <div id="info">
        <div class="info-item">
            <div class="info-label">일출 방위각</div>
            <div class="info-value" id="sunriseAzimuth">-</div>
        </div>
        <div class="info-item">
            <div class="info-label">일몰 방위각</div>
            <div class="info-value" id="sunsetAzimuth">-</div>
        </div>
        <div class="info-item">
            <div class="info-label">남중 고도</div>
            <div class="info-value" id="noonAltitude">-</div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 전역 변수
        let mainScene, mainCamera, mainRenderer;
        let topScene, topCamera, topRenderer;
        let sphereScene, sphereCamera, sphereRenderer;
        let earth, sun, earthOrbit, earthTop;
        let observerLat = 37.5, observerLon = 127;
        let sunRA = 0; // 시간 단위 (h)
        const earthTilt = 23.44 * Math.PI / 180;
        const DEG = Math.PI / 180;
        const RAD2DEG = 180 / Math.PI;

        // 천구 뷰 오브젝트 참조
        let celestialSphereMesh, equatorRing, eclipticRing, horizonRing, horizonGroup;
        let sunPathMesh = null, sunMarker = null;

        // 메인 뷰 초기화
        function initMainView() {
            const container = document.getElementById('mainView');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            mainScene = new THREE.Scene();
            mainCamera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            mainCamera.position.set(30, 20, 30);
            mainCamera.lookAt(0, 0, 0);
            
            mainRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            mainRenderer.setSize(width, height);
            mainRenderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(mainRenderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0x404040);
            mainScene.add(ambientLight);
            
            const sunLight = new THREE.PointLight(0xffff00, 2, 100);
            sunLight.position.set(0, 0, 0);
            mainScene.add(sunLight);
            
            // 태양
            const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1 });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            mainScene.add(sun);
            
            // 지구 공전 궤도
            const orbitGeometry = new THREE.RingGeometry(14.9, 15.1, 128);
            const orbitMaterial = new THREE.MeshBasicMaterial({ color: 0x4444ff, side: THREE.DoubleSide, opacity: 0.3, transparent: true });
            earthOrbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
            earthOrbit.rotation.x = -Math.PI / 2;
            mainScene.add(earthOrbit);
            
            // 지구
            const earthGeometry = new THREE.SphereGeometry(1, 32, 32);
            const earthMaterial = new THREE.MeshPhongMaterial({ color: 0x2233ff });
            earth = new THREE.Mesh(earthGeometry, earthMaterial);

            // 지구 자전축 표시
            const axisGeometry = new THREE.CylinderGeometry(0.05, 0.05, 4);
            const axisMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const axis = new THREE.Mesh(axisGeometry, axisMaterial);
            axis.position.set(0, 0, 0);
            axis.rotation.x = Math.PI / 2;
            earth.add(axis);
            
            mainScene.add(earth);
            
            // 마우스 컨트롤(우클릭 드래그로 카메라 궤도)
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            container.addEventListener('mousedown', (e) => {
                if (e.button === 2) {
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            container.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(mainCamera.position.clone());
                    spherical.theta -= deltaX * 0.01;
                    spherical.phi += deltaY * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    
                    mainCamera.position.setFromSpherical(spherical);
                    mainCamera.lookAt(0, 0, 0);
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            container.addEventListener('mouseup', () => { isDragging = false; });
            container.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        // 위에서 본 뷰 초기화
        function initTopView() {
            const container = document.getElementById('topView');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            topScene = new THREE.Scene();
            topCamera = new THREE.OrthographicCamera(-20, 20, 20 * height/width, -20 * height/width, 0.1, 1000);
            topCamera.position.set(0, 50, 0);
            topCamera.lookAt(0, 0, 0);
            
            topRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            topRenderer.setSize(width, height);
            topRenderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(topRenderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0x808080);
            topScene.add(ambientLight);
            
            // 태양(중앙)
            const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const sunTop = new THREE.Mesh(sunGeometry, sunMaterial);
            topScene.add(sunTop);
            
            // 지구 궤도
            const orbitGeometry = new THREE.RingGeometry(14.5, 15.5, 128);
            const orbitMaterial = new THREE.MeshBasicMaterial({ color: 0x4444ff, opacity: 0.5, transparent: true });
            const orbitTop = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbitTop.rotation.x = -Math.PI / 2;
            topScene.add(orbitTop);

            // 지구(상단 뷰)
            const earthGeometry = new THREE.SphereGeometry(1, 16, 16);
            const earthMaterial = new THREE.MeshBasicMaterial({ color: 0x2244ff });
            earthTop = new THREE.Mesh(earthGeometry, earthMaterial);
            topScene.add(earthTop);
        }
        
        // 천구 뷰 초기화 (제삼자 시점: 카메라가 바깥에서 원점(관측자)을 내려다봄)
        function initCelestialSphere() {
            const container = document.getElementById('celestialSphere');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            sphereScene = new THREE.Scene();
            sphereCamera = new THREE.PerspectiveCamera(60, width / height, 0.1, 2000);

            // 제삼자 시점 카메라 위치(구 바깥)
            let camSpherical = new THREE.Spherical(140, Math.PI/3, Math.PI/4);
            sphereCamera.position.setFromSpherical(camSpherical);
            sphereCamera.lookAt(0, 0, 0);
            
            sphereRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            sphereRenderer.setSize(width, height);
            sphereRenderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(sphereRenderer.domElement);
            
            // 천구(반투명)
            const sphereGeometry = new THREE.SphereGeometry(50, 64, 64);
            const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x000033, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
            celestialSphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphereScene.add(celestialSphereMesh);
            
            // 적도(Equator) - 세계 좌표에서 XY 평면, NCP는 +Z
            const equatorGeometry = new THREE.TorusGeometry(50, 0.2, 8, 128);
            const equatorMaterial = new THREE.MeshBasicMaterial({ color: 0xff4444 });
            equatorRing = new THREE.Mesh(equatorGeometry, equatorMaterial);
            equatorRing.rotation.set(0, 0, 0); // XY 평면
            sphereScene.add(equatorRing);
            
            // 황도(Ecliptic) - 적도 기준 23.44° 기울임(γ점이 +X 방향이라고 가정)
            const eclipticGeometry = new THREE.TorusGeometry(50, 0.2, 8, 128);
            const eclipticMaterial = new THREE.MeshBasicMaterial({ color: 0xffdd00 });
            eclipticRing = new THREE.Mesh(eclipticGeometry, eclipticMaterial);
            eclipticRing.rotation.x = earthTilt; // X축 기준 기울임
            sphereScene.add(eclipticRing);
            
            // 지평선(Horizon) - 관측자 위도 φ에 따라 기울이고, LST에 따라 Z축 회전
            const horizonGeometry = new THREE.TorusGeometry(50, 0.2, 8, 128);
            const horizonMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
            horizonRing = new THREE.Mesh(horizonGeometry, horizonMaterial);
            horizonGroup = new THREE.Object3D();
            horizonGroup.add(horizonRing);
            sphereScene.add(horizonGroup);

            // 카메라 드래그/줌(우클릭 회전, 휠 줌)
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            container.addEventListener('mousedown', (e) => {
                if (e.button === 2) {
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            container.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    camSpherical.setFromVector3(sphereCamera.position.clone());
                    camSpherical.theta -= deltaX * 0.01;
                    camSpherical.phi += deltaY * 0.01;
                    camSpherical.phi = Math.max(0.05, Math.min(Math.PI - 0.05, camSpherical.phi));
                    sphereCamera.position.setFromSpherical(camSpherical);
                    sphereCamera.lookAt(0, 0, 0);
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            container.addEventListener('mouseup', () => { isDragging = false; });
            container.addEventListener('wheel', (e) => {
                camSpherical.setFromVector3(sphereCamera.position.clone());
                camSpherical.radius *= (e.deltaY > 0 ? 1.05 : 0.95);
                camSpherical.radius = Math.max(70, Math.min(400, camSpherical.radius));
                sphereCamera.position.setFromSpherical(camSpherical);
                sphereCamera.lookAt(0, 0, 0);
            });
            container.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        // 시뮬레이션 업데이트
        function updateSimulation() {
            sunRA = parseFloat(document.getElementById('rightAscension').value);
            observerLat = parseFloat(document.getElementById('latitude').value);
            observerLon = parseFloat(document.getElementById('longitude').value);
            
            // 지구 위치 업데이트 (RA에 따라 단순 매핑: 춘분=0h에서 시작, 반시계 방향)
            const angle = (sunRA / 24) * 2 * Math.PI;
            const ex = 15 * Math.cos(angle);
            const ez = 15 * Math.sin(angle);
            earth.position.set(ex, 0, ez);
            earth.rotation.z = earthTilt;

            // 상단(탑) 뷰의 지구 위치도 갱신
            if (earthTop) earthTop.position.set(ex, 0, ez);
            
            // 천구 업데이트
            updateCelestialSphere();
            
            // 태양 정보 계산
            calculateSunPosition();
        }
        
        // 천구 업데이트 (제삼자 시점)
        function updateCelestialSphere() {
            const latRad = observerLat * DEG;
            const alpha = sunRA * Math.PI / 12; // 적경(라디안)
            const epsilon = 23.44 * DEG;
            const declination = epsilon * Math.sin(alpha); // 시연용 근사식
            const R = 50;

            // 지평선 기울기: 기본(적도=XY)에 대해 X축으로 (φ - 90°)만큼 회전 -> 법선이 (0, cosφ, sinφ)
            horizonGroup.rotation.set(0, 0, 0);
            horizonRing.rotation.set(0, 0, 0);
            horizonGroup.rotation.x = latRad - Math.PI / 2;

            // 편의상 LST를 적경과 동일하게 맞춰 남중 시각 장면으로 보이게 Z축 회전
            // (필요 시 실제 LST를 계산해 대체 가능)
            horizonGroup.rotation.z = alpha;

            // 태양의 일주 경로(동일 적경에서의 일주가 아니라, 고정된 적위에서의 소권)
            if (sunPathMesh) {
                sphereScene.remove(sunPathMesh);
                sunPathMesh.geometry.dispose();
                sunPathMesh.material.dispose();
                sunPathMesh = null;
            }
            const rSmall = Math.max(0.1, R * Math.cos(declination)); // 소권 반지름
            const zOffset = R * Math.sin(declination);               // 소권 z 오프셋
            const sunPathGeometry = new THREE.RingGeometry(rSmall - 0.25, rSmall + 0.25, 256);
            const sunPathMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500, opacity: 0.8, transparent: true, side: THREE.DoubleSide });
            sunPathMesh = new THREE.Mesh(sunPathGeometry, sunPathMaterial);
            sunPathMesh.position.set(0, 0, zOffset); // 적도와 평행한 평면에서 z로 이동
            sphereScene.add(sunPathMesh);

            // 태양 위치(적경·적위 기준의 등방향 좌표; 제삼자 시점에서는 고정)
            if (sunMarker) {
                sphereScene.remove(sunMarker);
                sunMarker.geometry.dispose();
                sunMarker.material.dispose();
                sunMarker = null;
            }
            const sunGeom = new THREE.SphereGeometry(2, 24, 24);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            sunMarker = new THREE.Mesh(sunGeom, sunMat);
            const x = R * Math.cos(declination) * Math.cos(alpha);
            const y = R * Math.cos(declination) * Math.sin(alpha);
            const z = R * Math.sin(declination);
            sunMarker.position.set(x, y, z);
            sphereScene.add(sunMarker);

            // 적도/황도는 고정(이미 초기화 시 배치)
            equatorRing.rotation.set(0, 0, 0);
            eclipticRing.rotation.set(earthTilt, 0, 0);
        }
        
        // 태양 위치 계산(남중 고도, 일출/일몰 방위각)
        function calculateSunPosition() {
            const latRad = observerLat * DEG;
            const alpha = sunRA * Math.PI / 12; // RA
            const decRad = 23.44 * DEG * Math.sin(alpha); // 근사 적위

            // 남중 고도
            const noonAlt = 90 - Math.abs(observerLat - (decRad * RAD2DEG));

            // 일출/일몰 시간의 시간각(H0) 및 방위각
            const tanLat = Math.tan(latRad);
            const tanDec = Math.tan(decRad);
            const cosH0 = -tanLat * tanDec;

            let sunriseAz = "-", sunsetAz = "-";

            if (cosH0 > 1) {
                // 항상 지평선 아래(극야)
                sunriseAz = "극야";
                sunsetAz = "극야";
            } else if (cosH0 < -1) {
                // 항상 지평선 위(백야)
                sunriseAz = "백야";
                sunsetAz = "백야";
            } else {
                const H0 = Math.acos(cosH0); // 0~π
                // h=0일 때 방위각: sinA = cosδ sinH, cosA = sinδ / cosφ
                const cosA = Math.sin(decRad) / Math.max(1e-9, Math.cos(latRad));
                const sinA_rise = Math.cos(decRad) * Math.sin(-H0); // 일출(H 음수)
                const sinA_set  = Math.cos(decRad) * Math.sin( H0); // 일몰(H 양수)
                
                let Ar = Math.atan2(sinA_rise, cosA) * RAD2DEG; // 일출
                let As = Math.atan2(sinA_set,  cosA) * RAD2DEG; // 일몰

                // 0~360 정규화
                Ar = (Ar % 360 + 360) % 360;
                As = (As % 360 + 360) % 360;

                sunriseAz = Ar.toFixed(1) + "°";
                sunsetAz  = As.toFixed(1) + "°";
            }

            document.getElementById('sunriseAzimuth').textContent = sunriseAz;
            document.getElementById('sunsetAzimuth').textContent = sunsetAz;
            document.getElementById('noonAltitude').textContent = noonAlt.toFixed(1) + "°";
        }
        
        // 애니메이션
        function animate() {
            requestAnimationFrame(animate);
            if (mainRenderer && mainScene && mainCamera) mainRenderer.render(mainScene, mainCamera);
            if (topRenderer && topScene && topCamera) topRenderer.render(topScene, topCamera);
            if (sphereRenderer && sphereScene && sphereCamera) sphereRenderer.render(sphereScene, sphereCamera);
        }
        
        // 윈도우 리사이즈 처리
        function onWindowResize() {
            const containers = ['mainView', 'topView', 'celestialSphere'];
            const renderers = [mainRenderer, topRenderer, sphereRenderer];
            const cameras = [mainCamera, topCamera, sphereCamera];
            
            containers.forEach((id, index) => {
                const container = document.getElementById(id);
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                if (renderers[index]) {
                    renderers[index].setSize(width, height);
                    if (cameras[index] instanceof THREE.PerspectiveCamera) {
                        cameras[index].aspect = width / height;
                        cameras[index].updateProjectionMatrix();
                    } else if (cameras[index] instanceof THREE.OrthographicCamera) {
                        cameras[index].top = 20 * height/width;
                        cameras[index].bottom = -20 * height/width;
                        cameras[index].updateProjectionMatrix();
                    }
                }
            });
        }
        
        // 초기화
        window.addEventListener('load', () => {
            initMainView();
            initTopView();
            initCelestialSphere();
            updateSimulation();
            animate();
            window.addEventListener('resize', onWindowResize);
        });
    </script>
</body>
</html>
