<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>천구 좌표계 시뮬레이션</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: white;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        #container {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            grid-template-rows: 1fr;
            gap: 10px;
            padding: 10px;
            height: 100vh;
            width: 100vw;
        }
        
        .canvas-container {
            background: rgba(20, 20, 30, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(100, 100, 150, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .canvas-title {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 10;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 30, 40, 0.95);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(100, 100, 150, 0.5);
            z-index: 100;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label {
            font-size: 12px;
            color: #aaa;
        }
        
        input, select {
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #444;
            background: #222;
            color: white;
            width: 120px;
        }
        
        button {
            padding: 8px 20px;
            background: linear-gradient(135deg, #4a5568, #2d3748);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            background: linear-gradient(135deg, #5a6578, #3d4758);
            transform: translateY(-2px);
        }
        
        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(30, 30, 40, 0.95);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 250px;
            z-index: 100;
        }
        
        .info-item {
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(100, 100, 150, 0.2);
        }
        
        .info-label {
            color: #8a8a8a;
            font-size: 12px;
        }
        
        .info-value {
            color: #fff;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="canvas-container" id="topView">
            <div class="canvas-title">태양-지구 (위에서 본 모습)</div>
        </div>
        <div class="canvas-container" id="mainView">
            <div class="canvas-title">태양계 공전 (3D)</div>
        </div>
        <div class="canvas-container" id="celestialSphere">
            <div class="canvas-title">천구 (관측자 시점)</div>
        </div>
    </div>
    
    <div id="controls">
        <div class="control-group">
            <label>태양 적경 (RA)</label>
            <select id="rightAscension">
                <option value="0">0h (춘분)</option>
                <option value="6">6h (하지)</option>
                <option value="12">12h (추분)</option>
                <option value="18">18h (동지)</option>
            </select>
        </div>
        <div class="control-group">
            <label>관측자 위도</label>
            <input type="number" id="latitude" value="37.5" min="-90" max="90" step="0.1">
        </div>
        <div class="control-group">
            <label>관측자 경도</label>
            <input type="number" id="longitude" value="127" min="-180" max="180" step="0.1">
        </div>
        <button onclick="updateSimulation()">적용</button>
    </div>
    
    <div id="info">
        <div class="info-item">
            <div class="info-label">일출 방위각</div>
            <div class="info-value" id="sunriseAzimuth">-</div>
        </div>
        <div class="info-item">
            <div class="info-label">일몰 방위각</div>
            <div class="info-value" id="sunsetAzimuth">-</div>
        </div>
        <div class="info-item">
            <div class="info-label">남중 고도</div>
            <div class="info-value" id="noonAltitude">-</div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 전역 변수
        let mainScene, mainCamera, mainRenderer;
        let topScene, topCamera, topRenderer;
        let sphereScene, sphereCamera, sphereRenderer;
        let earth, sun, earthOrbit;
        let observerLat = 37.5, observerLon = 127;
        let sunRA = 0; // 시간 단위
        let earthTilt = 23.5 * Math.PI / 180;
        
        // 메인 뷰 초기화
        function initMainView() {
            const container = document.getElementById('mainView');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            mainScene = new THREE.Scene();
            mainCamera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            mainCamera.position.set(30, 20, 30);
            mainCamera.lookAt(0, 0, 0);
            
            mainRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            mainRenderer.setSize(width, height);
            container.appendChild(mainRenderer.domElement);
            
            // 조명
            const ambientLight = new THREE.AmbientLight(0x404040);
            mainScene.add(ambientLight);
            
            const sunLight = new THREE.PointLight(0xffff00, 2, 100);
            sunLight.position.set(0, 0, 0);
            mainScene.add(sunLight);
            
            // 태양
            const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 1
            });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            mainScene.add(sun);
            
            // 지구 공전 궤도
            const orbitGeometry = new THREE.RingGeometry(14.9, 15.1, 64);
            const orbitMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x4444ff, 
                side: THREE.DoubleSide,
                opacity: 0.3,
                transparent: true
            });
            earthOrbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
            earthOrbit.rotation.x = -Math.PI / 2;
            mainScene.add(earthOrbit);
            
            // 지구
            const earthGeometry = new THREE.SphereGeometry(1, 32, 32);
            const earthMaterial = new THREE.MeshPhongMaterial({ color: 0x2233ff });
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            
            // 지구 자전축 표시
            const axisGeometry = new THREE.CylinderGeometry(0.05, 0.05, 4);
            const axisMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const axis = new THREE.Mesh(axisGeometry, axisMaterial);
            earth.add(axis);
            
            mainScene.add(earth);
            
            // 마우스 컨트롤
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            container.addEventListener('mousedown', (e) => {
                if (e.button === 2) {
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            
            container.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(mainCamera.position);
                    spherical.theta -= deltaX * 0.01;
                    spherical.phi += deltaY * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    
                    mainCamera.position.setFromSpherical(spherical);
                    mainCamera.lookAt(0, 0, 0);
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            
            container.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            container.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        // 위에서 본 뷰 초기화
        function initTopView() {
            const container = document.getElementById('topView');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            topScene = new THREE.Scene();
            topCamera = new THREE.OrthographicCamera(
                -20, 20, 20 * height/width, -20 * height/width, 0.1, 1000
            );
            topCamera.position.set(0, 50, 0);
            topCamera.lookAt(0, 0, 0);
            
            topRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            topRenderer.setSize(width, height);
            container.appendChild(topRenderer.domElement);
            
            // 조명
            const ambientLight = new THREE.AmbientLight(0x808080);
            topScene.add(ambientLight);
            
            // 태양 (복사본)
            const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const sunTop = new THREE.Mesh(sunGeometry, sunMaterial);
            topScene.add(sunTop);
            
            // 지구 궤도
            const orbitGeometry = new THREE.RingGeometry(14.5, 15.5, 64);
            const orbitMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x4444ff, 
                opacity: 0.5,
                transparent: true
            });
            const orbitTop = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbitTop.rotation.x = -Math.PI / 2;
            topScene.add(orbitTop);
        }
        
        // 천구 뷰 초기화
        function initCelestialSphere() {
            const container = document.getElementById('celestialSphere');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            sphereScene = new THREE.Scene();
            sphereCamera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
            sphereCamera.position.set(0, 0, 0);
            
            sphereRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            sphereRenderer.setSize(width, height);
            container.appendChild(sphereRenderer.domElement);
            
            // 천구 (반투명)
            const sphereGeometry = new THREE.SphereGeometry(50, 64, 64);
            const sphereMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x000033,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const celestialSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphereScene.add(celestialSphere);
            
            // 지평선
            const horizonGeometry = new THREE.RingGeometry(49.5, 50.5, 64);
            const horizonMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                side: THREE.DoubleSide
            });
            const horizon = new THREE.Mesh(horizonGeometry, horizonMaterial);
            sphereScene.add(horizon);
            
            // 적도
            const equatorGeometry = new THREE.TorusGeometry(50, 0.2, 8, 100);
            const equatorMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const equator = new THREE.Mesh(equatorGeometry, equatorMaterial);
            sphereScene.add(equator);
            
            // 황도
            const eclipticGeometry = new THREE.TorusGeometry(50, 0.2, 8, 100);
            const eclipticMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const ecliptic = new THREE.Mesh(eclipticGeometry, eclipticMaterial);
            ecliptic.rotation.x = earthTilt;
            sphereScene.add(ecliptic);
            
            // 마우스 컨트롤
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let theta = 0, phi = Math.PI / 2;
            
            container.addEventListener('mousedown', (e) => {
                if (e.button === 2) {
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            
            container.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    theta += deltaX * 0.01;
                    phi -= deltaY * 0.01;
                    phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
                    
                    sphereCamera.lookAt(
                        Math.sin(phi) * Math.cos(theta),
                        Math.cos(phi),
                        Math.sin(phi) * Math.sin(theta)
                    );
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            
            container.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            container.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        // 시뮬레이션 업데이트
        function updateSimulation() {
            sunRA = parseFloat(document.getElementById('rightAscension').value);
            observerLat = parseFloat(document.getElementById('latitude').value);
            observerLon = parseFloat(document.getElementById('longitude').value);
            
            // 지구 위치 업데이트 (RA에 따라)
            const angle = (sunRA / 24) * 2 * Math.PI;
            earth.position.x = 15 * Math.cos(angle);
            earth.position.z = 15 * Math.sin(angle);
            earth.rotation.z = earthTilt;
            
            // 천구 업데이트
            updateCelestialSphere();
            
            // 태양 정보 계산
            calculateSunPosition();
        }
        
        // 천구 업데이트
        function updateCelestialSphere() {
            // 위도에 따른 지평선 기울기 조정
            const latRad = observerLat * Math.PI / 180;
            
            // 적도와 황도의 상대적 위치 조정
            sphereScene.children.forEach(child => {
                if (child.geometry && child.geometry.type === 'TorusGeometry') {
                    if (child.material.color.getHex() === 0xff0000) { // 적도
                        child.rotation.y = 0;
                        child.rotation.z = latRad;
                    }
                }
            });
            
            // 태양의 일주운동 경로 표시
            const sunPathGeometry = new THREE.TorusGeometry(45, 0.3, 8, 100);
            const sunPathMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffa500,
                opacity: 0.7,
                transparent: true
            });
            
            // 기존 태양 경로 제거
            sphereScene.children = sphereScene.children.filter(child => 
                !(child.material && child.material.color && child.material.color.getHex() === 0xffa500)
            );
            
            const sunPath = new THREE.Mesh(sunPathGeometry, sunPathMaterial);
            const declination = 23.5 * Math.sin((sunRA / 12) * Math.PI) * Math.PI / 180;
            sunPath.rotation.x = Math.PI / 2 - latRad + declination;
            sphereScene.add(sunPath);
            
            // 태양 위치 표시
            const sunGeometry = new THREE.SphereGeometry(2, 16, 16);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            
            // 기존 태양 제거
            sphereScene.children = sphereScene.children.filter(child =>
                !(child.geometry && child.geometry.type === 'SphereGeometry' && child.material.color.getHex() === 0xffff00)
            );
            
            const sunSphere = new THREE.Mesh(sunGeometry, sunMaterial);
            const hourAngle = 0; // 남중 시각
            sunSphere.position.x = 45 * Math.cos(declination) * Math.sin(hourAngle);
            sunSphere.position.y = 45 * (Math.sin(declination) * Math.cos(latRad) + 
                                        Math.cos(declination) * Math.sin(latRad) * Math.cos(hourAngle));
            sunSphere.position.z = 45 * (Math.sin(declination) * Math.sin(latRad) - 
                                        Math.cos(declination) * Math.cos(latRad) * Math.cos(hourAngle));
            sphereScene.add(sunSphere);
        }
        
        // 태양 위치 계산
        function calculateSunPosition() {
            const latRad = observerLat * Math.PI / 180;
            const declination = 23.5 * Math.sin((sunRA / 12) * Math.PI);
            const decRad = declination * Math.PI / 180;
            
            // 남중 고도
            const noonAlt = 90 - Math.abs(observerLat - declination);
            
            // 일출/일몰 방위각
            const cosH = -Math.tan(latRad) * Math.tan(decRad);
            let sunriseAz, sunsetAz;
            
            if (Math.abs(cosH) <= 1) {
                const H = Math.acos(cosH);
                const sinAz = Math.cos(decRad) * Math.sin(H) / Math.cos(0);
                const cosAz = (Math.sin(decRad) - Math.sin(0) * Math.sin(latRad)) / (Math.cos(0) * Math.cos(latRad));
                const Az = Math.atan2(sinAz, cosAz) * 180 / Math.PI;
                
                sunriseAz = (180 - Az).toFixed(1);
                sunsetAz = (180 + Az).toFixed(1);
            } else {
                sunriseAz = cosH > 1 ? "극야" : "백야";
                sunsetAz = cosH > 1 ? "극야" : "백야";
            }
            
            document.getElementById('sunriseAzimuth').textContent = sunriseAz + "°";
            document.getElementById('sunsetAzimuth').textContent = sunsetAz + "°";
            document.getElementById('noonAltitude').textContent = noonAlt.toFixed(1) + "°";
        }
        
        // 애니메이션
        function animate() {
            requestAnimationFrame(animate);
            
            if (mainRenderer) mainRenderer.render(mainScene, mainCamera);
            if (topRenderer) topRenderer.render(topScene, topCamera);
            if (sphereRenderer) sphereRenderer.render(sphereScene, sphereCamera);
        }
        
        // 윈도우 리사이즈 처리
        function onWindowResize() {
            const containers = ['mainView', 'topView', 'celestialSphere'];
            const renderers = [mainRenderer, topRenderer, sphereRenderer];
            const cameras = [mainCamera, topCamera, sphereCamera];
            
            containers.forEach((id, index) => {
                const container = document.getElementById(id);
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                if (renderers[index]) {
                    renderers[index].setSize(width, height);
                    
                    if (cameras[index] instanceof THREE.PerspectiveCamera) {
                        cameras[index].aspect = width / height;
                        cameras[index].updateProjectionMatrix();
                    } else if (cameras[index] instanceof THREE.OrthographicCamera) {
                        cameras[index].top = 20 * height/width;
                        cameras[index].bottom = -20 * height/width;
                        cameras[index].updateProjectionMatrix();
                    }
                }
            });
        }
        
        // 초기화
        window.addEventListener('load', () => {
            initMainView();
            initTopView();
            initCelestialSphere();
            updateSimulation();
            animate();
            
            window.addEventListener('resize', onWindowResize);
        });
    </script>
</body>
</html>
