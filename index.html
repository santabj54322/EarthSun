<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>지평/적도 좌표계 시뮬레이터</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #0f1220;
      --panel: #13162a;
      --line1: #4cc9f0;  /* 적도 */
      --line2: #f72585;  /* 황도 */
      --line3: #ffd166;  /* 태양 일주 */
      --horizon: #888;
      --text: #e9ecff;
      --accent: #85f489;
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; height: 100%; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    header {
      padding: 10px 14px;
      display: grid; gap: 8px; align-items: center;
      grid-template-columns: auto auto auto auto auto 1fr auto;
      background: #0d1020; border-bottom: 1px solid #222743;
      position: sticky; top: 0; z-index: 5;
    }
    header label { font-size: 13px; opacity: 0.9; margin-right: 6px; }
    header input {
      width: 90px; padding: 6px 8px; background: #0a0d1a; border: 1px solid #273056; border-radius: 6px; color: var(--text);
    }
    header button {
      padding: 8px 14px; background: #2a3a7a; color: #fff; border: none; border-radius: 8px; cursor: pointer;
    }
    header .help { font-size: 12px; opacity: 0.8; }
    #grid {
      display: grid; gap: 10px; padding: 10px;
      grid-template-columns: 1fr 2fr 1fr;
      grid-template-areas: "top main sky";
      height: calc(100% - 64px);
    }
    @media (max-width: 1100px) {
      #grid {
        grid-template-columns: 1fr;
        grid-template-areas:
          "main"
          "top"
          "sky";
        height: auto;
      }
    }
    .panel {
      background: var(--panel);
      border: 1px solid #222743; border-radius: 10px;
      position: relative; min-height: 260px; overflow: hidden;
    }
    .panel .title {
      position: absolute; left: 10px; top: 8px; font-size: 12px; opacity: 0.8; z-index: 2;
    }
    .panel canvas { display: block; width: 100%; height: 100%; }
    #topdown { grid-area: top; }
    #main { grid-area: main; min-height: 420px; }
    #localsky { grid-area: sky; }
    #localsky .info {
      position: absolute; left: 10px; bottom: 10px; font-size: 13px; background: rgba(6,8,18,0.6);
      border: 1px solid #2b3259; padding: 8px 10px; border-radius: 8px; backdrop-filter: blur(4px);
    }
    .note { padding: 6px 12px; font-size: 12px; opacity: 0.8; }
    a { color: #9ed0ff; text-decoration: none; }
  </style>
</head>
<body>
  <header>
    <label>태양 적경</label>
    <input id="raInput" placeholder="예: 6h 또는 6:00" />
    <label>위도 φ(°)</label>
    <input id="latInput" placeholder="예: 37.5" />
    <label>경도 λ(°)</label>
    <input id="lonInput" placeholder="예: 127.0" />
    <div class="help">RA·위도·경도 입력 → 적용</div>
    <button id="applyBtn">적용</button>
  </header>

  <div id="grid">
    <div id="topdown" class="panel">
      <div class="title">1) 지구-태양 상공에서 본 모습</div>
    </div>
    <div id="main" class="panel">
      <div class="title">3) 지구의 공전(메인)</div>
    </div>
    <div id="localsky" class="panel">
      <div class="title">2) 관측자 천구</div>
      <div id="info" class="info">적용을 눌러 계산합니다</div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.159.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.159.0/examples/jsm/controls/OrbitControls.js";

    // ====== 수학/상수 ======
    const deg2rad = d => d * Math.PI / 180;
    const rad2deg = r => r * 180 / Math.PI;
    const hours2rad = h => h * Math.PI / 12;
    const clamp = (x,a,b) => Math.max(a, Math.min(b, x));
    const EPS = deg2rad(23.439281); // 지구 자전축 기울기(황도 경사)

    function raToEcliptic(alpha, eps = EPS) {
      const s = Math.sin(alpha), c = Math.cos(alpha);
      const lam = Math.atan2(s / Math.cos(eps), c);   // 황경 λ
      const dec = Math.asin(Math.sin(eps) * Math.sin(lam)); // 태양 적위 δ
      return { lam, dec };
    }

    function eqToHor(dec, H, lat) {
      const sinφ = Math.sin(lat), cosφ = Math.cos(lat);
      const sinδ = Math.sin(dec), cosδ = Math.cos(dec);
      const sinh = sinφ * sinδ + cosφ * cosδ * Math.cos(H);
      const h = Math.asin(clamp(sinh, -1, 1));
      const cosh = Math.cos(h) || 1e-12;
      const sinA = -cosδ * Math.sin(H) / cosh;
      const cosA = (cosφ * sinδ - sinφ * cosδ * Math.cos(H)) / cosh;
      let A = Math.atan2(sinA, cosA);
      if (A < 0) A += 2*Math.PI; // [0,2π)
      return { A, h };
    }

    function riseSetAz(lat, dec) {
      const tanφ = Math.tan(lat), tanδ = Math.tan(dec);
      const X = -(tanφ * tanδ);
      if (!isFinite(X) || Math.abs(X) > 1) return null; // 없음(백야/극야)
      const H0 = Math.acos(clamp(X, -1, 1));
      const cosA0 = clamp(Math.sin(dec) / Math.cos(lat), -1, 1);
      const A0 = Math.acos(cosA0);
      return { H0, A_rise: 2*Math.PI - A0, A_set: A0 };
    }

    const hMeridian = (lat, dec) => deg2rad(90) - Math.abs(lat - dec);

    function sampleDiurnal(dec, lat, n=361) {
      const pts = [];
      for (let i=0;i<n;i++) {
        const H = -Math.PI + (2*Math.PI*i)/(n-1);
        const {A,h} = eqToHor(dec, H, lat);
        pts.push({A,h});
      }
      return pts;
    }

    function A_h_toVec(A,h, r=1) {
      // 축 설정: +Y 위(고도), +Z 북, +X 동
      const ch = Math.cos(h), sh = Math.sin(h);
      const sA = Math.sin(A), cA = Math.cos(A);
      return new THREE.Vector3(r*ch*sA, r*sh, r*ch*cA);
    }

    function parseRA(str) {
      if (!str) return NaN;
      const s = str.trim().toLowerCase().replace(/\s+/g,'');
      let h=0,m=0,sec=0;
      if (s.includes(':')) {
        const parts = s.split(':').map(Number);
        h = parts[0]||0; m = parts[1]||0; sec = parts[2]||0;
      } else if (s.includes('h')) {
        const [hpart, rest] = s.split('h');
        h = parseFloat(hpart)||0;
        if (rest && rest.includes('m')) {
          const [mpart, spart] = rest.split('m');
          m = parseFloat(mpart)||0;
          if (spart && spart.endsWith('s')) sec = parseFloat(spart)||0;
        } else if (rest && rest.endsWith('m')) {
          m = parseFloat(rest)||0;
        } else if (rest && rest.endsWith('s')) {
          sec = parseFloat(rest)||0;
        } else if (rest) {
          m = parseFloat(rest)||0;
        }
      } else if (s.endsWith('h')) {
        h = parseFloat(s)||0;
      } else {
        h = parseFloat(s)||0;
      }
      const hours = h + m/60 + sec/3600;
      return hours2rad(hours);
    }

    // ====== 씬/렌더러 준비 ======
    const elTop = document.getElementById('topdown');
    const elMain = document.getElementById('main');
    const elSky = document.getElementById('localsky');
    const info = document.getElementById('info');

    // 공통 헬퍼: 캔버스 오른쪽 클릭 메뉴 방지
    const preventContextMenu = el => el.addEventListener('contextmenu', e => e.preventDefault());

    // 메인 공전 씬
    const sceneMain = new THREE.Scene();
    sceneMain.background = new THREE.Color(0x0b0e1a);
    const camMain = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
    camMain.position.set(18, 10, 18);
    const renMain = new THREE.WebGLRenderer({ antialias: true });
    elMain.appendChild(renMain.domElement); preventContextMenu(renMain.domElement);
    const controlsMain = new OrbitControls(camMain, renMain.domElement);
    controlsMain.enablePan = false;
    controlsMain.mouseButtons.LEFT = THREE.MOUSE.PAN; // 왼쪽 드래그 무시
    controlsMain.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;

    // 상공(탑다운) 씬
    const sceneTop = new THREE.Scene();
    sceneTop.background = new THREE.Color(0x0b0e1a);
    const camTop = new THREE.PerspectiveCamera(40, 1, 0.1, 1000);
    camTop.position.set(0, 0, 30); camTop.lookAt(0,0,0);
    const renTop = new THREE.WebGLRenderer({ antialias: true });
    elTop.appendChild(renTop.domElement); preventContextMenu(renTop.domElement);

    // 로컬 천구 씬
    const sceneSky = new THREE.Scene();
    sceneSky.background = new THREE.Color(0x0b0e1a);
    const camSky = new THREE.PerspectiveCamera(55, 1, 0.01, 100);
    camSky.position.set(0, 1.6, 2.6);
    const renSky = new THREE.WebGLRenderer({ antialias: true });
    elSky.appendChild(renSky.domElement); preventContextMenu(renSky.domElement);
    const controlsSky = new OrbitControls(camSky, renSky.domElement);
    controlsSky.enablePan = false;
    controlsSky.mouseButtons.LEFT = THREE.MOUSE.PAN;
    controlsSky.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;
    controlsSky.minDistance = 1.5; controlsSky.maxDistance = 6;

    // ====== 공전/상공 공통 오브젝트 ======
    function buildOrbitScene(targetScene, scale=10) {
      const group = new THREE.Group();

      // 태양
      const sunGeo = new THREE.SphereGeometry(1.2, 32, 16);
      const sunMat = new THREE.MeshBasicMaterial({ color: 0xffd166 });
      const sun = new THREE.Mesh(sunGeo, sunMat);
      group.add(sun);

      // 지구 궤도(황도면)
      const orbitGeo = new THREE.RingGeometry(scale-0.01, scale+0.01, 256);
      const orbitMat = new THREE.MeshBasicMaterial({ color: 0x2848a0, side: THREE.DoubleSide, transparent: true, opacity: 0.35 });
      const orbit = new THREE.Mesh(orbitGeo, orbitMat);
      orbit.rotation.x = Math.PI/2; // XY 평면에 눕히기
      group.add(orbit);

      // 춘분점 방향(+X)
      const axisX = new THREE.ArrowHelper(new THREE.Vector3(1,0,0).normalize(), new THREE.Vector3(0,0,0), scale*1.2, 0x66e0ff, 0.5, 0.25);
      group.add(axisX);

      // 지구
      const earthGroup = new THREE.Group();
      const eGeo = new THREE.SphereGeometry(0.6, 32, 16);
      const eMat = new THREE.MeshPhongMaterial({ color: 0x2b9df0, emissive: 0x001428, shininess: 40 });
      const earth = new THREE.Mesh(eGeo, eMat);
      earthGroup.add(earth);

      // 지구 적도 링(자전축 기울기 시각화)
      const eqLine = new THREE.LineLoop(
        new THREE.BufferGeometry().setFromPoints(
          [...Array(256)].map((_,i)=> {
            const t = 2*Math.PI*i/256;
            return new THREE.Vector3(Math.cos(t)*1.0, Math.sin(t)*0, 0);
          })
        ),
        new THREE.LineBasicMaterial({ color: 0x8be3ff })
      );
      eqLine.rotation.x = EPS; // 황도면 대비 +ε 기울기
      earthGroup.add(eqLine);

      // 자전축(세계 좌표에서 고정 방향: (0, -sinε, cosε))
      const axisDir = new THREE.Vector3(0, -Math.sin(EPS), Math.cos(EPS)).normalize();
      const axisGeom = new THREE.BufferGeometry().setFromPoints([axisDir.clone().multiplyScalar(-1.0), axisDir.clone().multiplyScalar(1.0)]);
      const axisLine = new THREE.Line(axisGeom, new THREE.LineBasicMaterial({ color: 0xffffff }));
      earthGroup.add(axisLine);

      group.add(earthGroup);

      // 라이트
      const amb = new THREE.AmbientLight(0xffffff, 0.4); group.add(amb);
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(-5, 5, 8); group.add(dir);

      targetScene.add(group);

      return { group, earthGroup, earth, setEarthPos(lamRad) {
        // 태양-지구 방향: r̂_sun = [cos λ, sin λ, 0], 지구는 반대
        const R = scale;
        earthGroup.position.set(-R*Math.cos(lamRad), -R*Math.sin(lamRad), 0);
      }};
    }

    const main = buildOrbitScene(sceneMain, 10);
    const top = buildOrbitScene(sceneTop, 6);

    // ====== 로컬 천구 오브젝트 ======
    // 돔
    const dome = new THREE.Mesh(
      new THREE.SphereGeometry(1.2, 48, 32, 0, Math.PI*2, 0, Math.PI/2),
      new THREE.MeshBasicMaterial({ color: 0x0f1630, transparent: true, opacity: 0.35, side: THREE.BackSide })
    );
    dome.position.y = 0;
    sceneSky.add(dome);

    // 지평선
    const horizon = new THREE.LineLoop(
      new THREE.BufferGeometry().setFromPoints(
        [...Array(256)].map((_,i)=> {
          const A = 2*Math.PI*i/256;
          return A_h_toVec(A, 0, 1.0);
        })
      ),
      new THREE.LineBasicMaterial({ color: 0x999999 })
    );
    sceneSky.add(horizon);

    // 적도선, 황도선, 태양 일주 궤
    const equatorLine = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x4cc9f0 }));
    const eclipticLine = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xf72585 }));
    const sunDiurnalLine = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ vertexColors: true }));
    sceneSky.add(equatorLine, eclipticLine, sunDiurnalLine);

    // 일출/일몰 마커
    const markerGeo = new THREE.SphereGeometry(0.025, 16, 12);
    const markRise = new THREE.Mesh(markerGeo, new THREE.MeshBasicMaterial({ color: 0x71f28a }));
    const markSet  = new THREE.Mesh(markerGeo, new THREE.MeshBasicMaterial({ color: 0xf28484 }));
    sceneSky.add(markRise, markSet);
    markRise.visible = markSet.visible = false;

    // 라이트(천구에도 약간)
    sceneSky.add(new THREE.AmbientLight(0xffffff, 0.6));

    // ====== 크기/리사이즈 ======
    function fitRenderer(el, renderer, camera, pixelRatio = window.devicePixelRatio || 1) {
      const w = el.clientWidth, h = el.clientHeight;
      renderer.setPixelRatio(Math.min(2, pixelRatio));
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    function onResize() {
      fitRenderer(elMain, renMain, camMain);
      fitRenderer(elTop, renTop, camTop);
      fitRenderer(elSky, renSky, camSky);
    }
    window.addEventListener('resize', onResize);
    onResize();

    // ====== 상태/적용 ======
    const raInput = document.getElementById('raInput');
    const latInput = document.getElementById('latInput');
    const lonInput = document.getElementById('lonInput');
    document.getElementById('applyBtn').addEventListener('click', apply);

    // 초기값
    raInput.value = '6h';
    latInput.value = '37.5';
    lonInput.value = '127.0';
    apply();

    function apply() {
      const alpha = parseRA(raInput.value);
      const lat = deg2rad(parseFloat(latInput.value));
      const lon = deg2rad(parseFloat(lonInput.value)); // 현재 계산에는 사용하지 않음(시각/LST 미도입)

      if (!isFinite(alpha) || !isFinite(lat)) {
        info.textContent = '입력값을 확인하세요.';
        return;
      }

      // 태양 위치(황도 λ, 적위 δ)
      const { lam, dec } = raToEcliptic(alpha);

      // 공전/상공 화면 갱신
      main.setEarthPos(lam);
      top.setEarthPos(lam);

      // 로컬 천구: 적도선(δ=0), 황도선(β=0), 태양 일주궤(δ 고정, H스윕)
      // LST는 도입하지 않으므로, 황도선은 α(λ로부터 계산)와 H=-α를 사용(LST=0 가정)
      const eqPts = sampleDiurnal(0, lat, 721).map(p => A_h_toVec(p.A, p.h, 1.0));
      setLineFromPoints(equatorLine, eqPts);

      const eclPts = [];
      const LST = 0; // 고정
      for (let i=0;i<=720;i++) {
        const lam_i = -Math.PI + (2*Math.PI*i)/720;
        const dec_i = Math.asin(Math.sin(EPS) * Math.sin(lam_i));
        const alpha_i = Math.atan2(Math.sin(lam_i) * Math.cos(EPS), Math.cos(lam_i));
        const H_i = LST - alpha_i;
        const {A,h} = eqToHor(dec_i, H_i, lat);
        eclPts.push(A_h_toVec(A,h,1.0));
      }
      setLineFromPoints(eclipticLine, eclPts);

      const sunPts = sampleDiurnal(dec, lat, 721);
      setDiurnalColoredLine(sunDiurnalLine, sunPts);

      // 일출/일몰, 남중 고도
      const RS = riseSetAz(lat, dec);
      const hmax = hMeridian(lat, dec);
      if (RS) {
        const rPos = A_h_toVec(RS.A_rise, 0, 1.0);
        const sPos = A_h_toVec(RS.A_set , 0, 1.0);
        markRise.position.copy(rPos); markSet.position.copy(sPos);
        markRise.visible = markSet.visible = true;
        const AriseDeg = (rad2deg(RS.A_rise)).toFixed(1);
        const AsetDeg  = (rad2deg(RS.A_set )).toFixed(1);
        info.innerHTML = [
          `태양 적위 δ = ${rad2deg(dec).toFixed(2)}°`,
          `일출 방위각 = ${AriseDeg}°`,
          `일몰 방위각 = ${AsetDeg}°`,
          `남중 고도 = ${rad2deg(hmax).toFixed(2)}°`
        ].join('<br/>');
      } else {
        markRise.visible = markSet.visible = false;
        info.innerHTML = [
          `태양 적위 δ = ${rad2deg(dec).toFixed(2)}°`,
          `일출/일몰 없음(극지방 현상)`,
          `남중 고도 = ${rad2deg(hmax).toFixed(2)}°`
        ].join('<br/>');
      }
    }

    function setLineFromPoints(line, pts) {
      const arr = new Float32Array(pts.length * 3);
      pts.forEach((p,i) => { arr[3*i]=p.x; arr[3*i+1]=p.y; arr[3*i+2]=p.z; });
      line.geometry.dispose();
      line.geometry = new THREE.BufferGeometry();
      line.geometry.setAttribute('position', new THREE.BufferAttribute(arr, 3));
      line.geometry.computeBoundingSphere();
    }

    function setDiurnalColoredLine(line, AhPts) {
      const n = AhPts.length;
      const pos = new Float32Array(n*3);
      const col = new Float32Array(n*3);
      for (let i=0;i<n;i++) {
        const {A,h} = AhPts[i];
        const v = A_h_toVec(A,h,1.0);
        pos[3*i]=v.x; pos[3*i+1]=v.y; pos[3*i+2]=v.z;
        const c = h >= 0 ? new THREE.Color(0xffd166) : new THREE.Color(0x555555);
        col[3*i]=c.r; col[3*i+1]=c.g; col[3*i+2]=c.b;
      }
      line.geometry.dispose();
      line.geometry = new THREE.BufferGeometry();
      line.geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      line.geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));
      line.geometry.computeBoundingSphere();
      line.material.color = new THREE.Color(0xffffff); // vertexColors 우선
      line.material.vertexColors = true;
    }

    // ====== 렌더 루프 ======
    function animate() {
      requestAnimationFrame(animate);
      controlsMain.update();
      controlsSky.update();
      renMain.render(sceneMain, camMain);
      renTop.render(sceneTop, camTop);
      renSky.render(sceneSky, camSky);
    }
    animate();
  </script>

  <div class="note">
    참고: 원형 공전, 굴절/태양 시지름/시차/지구 타원체 등은 무시. 경도는 현재 시각(LST)을 도입하지 않아 계산에 사용하지 않습니다(향후 확장 지점).
  </div>
</body>
</html>
